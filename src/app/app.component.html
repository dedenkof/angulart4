<!-- Коли Angular рендерить app.component.html і натрапляє на <app-user>, він "розуміє", що це не звичайний HTML-тег, а компонент, створює екземпляр UserComponent, передає дані,
обчислює і рендерить шаблон user.component.html та і звертається до UserComponent для його обробки.
Angular використовує механізм прив’язки властивостей ([ ]). Він "зв’язує" значення з AppComponent
(наприклад, [user]="user") з відповідними @Input у UserComponent. Це не прямий виклик функції, а синхронізація даних через дерево компонентів.

Як Angular "бачить" зміни?
Angular використовує механізм change detection (виявлення змін). Якщо дані в users зміняться (наприклад, через нову логіку),
Angular перевірить прив’язки ([user]="user") і оновить лише ті <app-user>, які залежать від змін.

(select)="onSelectUser($event)" — слухає подію select від UserComponent і викликає метод onSelectUser у AppComponent з аргументом $event.

тег <app-user> має прив’язку до події через (select) (зверніть увагу на круглі дужки, на відміну від квадратних для @Input)
(select)="onUserSelected($event)" слухає подію select, яку видає UserComponent. Коли подія спрацьовує, Angular викликає метод onUserSelected у AppComponent,
передаючи аргумент $event (значення, надіслане через .emit()).

Angular "зв’язує" компоненти через selector і прив’язки ([ ]). Дані течуть від батьківського компонента (AppComponent) до дочірнього (UserComponent),
де обробляються й рендеряться. Немає зворотного "повернення" — це односторонній потік даних із подальшим рендерингом.
	-->

<app-header />

<main>
  <ul id="users">
    @for (user of users; track user.id) {
    <li>
      <app-user
        [user]="user"
        [selected]="user.id === selectedUserID"
        (select)="onSelectUser($event)"
      />
    </li>
    }
  </ul>

  @if(selectedUser) {
  <app-tasks [userId]="selectedUser.id" [name]="selectedUser.name" />
  }@else {
  <p id="fallback">Select a user to see their tasks!</p>
  }
</main>
